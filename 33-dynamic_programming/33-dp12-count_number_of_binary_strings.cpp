/*

    * count the no. of binary strings without consecutive 1's.
    (binary strings are those string which are made from only 0's and 1's (eg. 01001010001010)).
    Q : Given a positive integer N, count all possible distinct binary strings of length N
        such that there are no consecutive 1's.

    i/p : N = 3
    o/p : 5 (000,001,010,100,101)

        total string generated by N is 2³.
        000         100
        001         101
        010         110
        011         111

    * brute-force approach :
    -> generate all the binary strings of size n which takes time complexity O(2ⁿ).
    -> then check for consecutive 1's which takes time complexity O(n).
    -> which takes O(n*2ⁿ).

    * recursive approach :
    -> here, total no. of strings are dependent on previous strings
       # for length i :
                        xx...xx1     +  xx...xx0
        strings[i] = end_with_one[i] + end_with_zero[i]            .......................................[1]

    -> here if n = 1 then
        we get total 2 string (0,1)
        our base cases are for 1
        strings[1] = end_with_one[1] + end_with_zero[1]
                   =  1 + 1
                   =  2

      #  now, if string end with 1 then previous digit must be 0. and if string end with 0 then previous digit can be 0 or 1.
            end_with_one[i] = end_with_zero[i-1];                       .......................................[2]
                                  xx.x01
            end_with_zero[i] = end_with_zero[i-1] + end_with_one[i-1]  .......................................[3]
                                  xx...x00     +       xx...x10
                             = end_with_zero[i-1] + end_with_zero[i-2]    ................[4] using [2]

       =>  NOTE : so, formula [4] is looking like fibonacci number sequence's formula.

      #  so, total strings with no consecutive one's are :
        strings[i] = end_with_one[i] + end_with_zero[i]
                   = end_with_zero[i-1] + end_with_zero[i-1] + end_with_one[i-1]
                   = end_with_zero[i-1] + end_with_zero[i-1] + end_with_zero[i-2]
                   = end_with_zero[i-1] + end_with_zero[i]          ..................... using [4]
                   = end_with_zero[i+1]             ................. using [4]


        fibonacci series : 0,1,1,2,3,5,8
        and we know that strings[1] = 2 = end_with_zero[2] =  fibo(4)
                         strings[n] = end_with_zero[n+1] = fibo(n+3)

*/

#include <iostream>
using namespace std;

int main()
{
    int n;
    cout << "Enter length for strings : ";
    cin >> n;
    int one = 0, two = 1, temp;
    // generating fibonacci sequence using only O(1) space complexity and O(N) time complexity

    for (int i = 0; i <= (n - 3) + 3; i++)
    {
        one += two;
        temp = two;
        two = one;
        one = temp;
    }
    if (n == 0)
    {
        cout << "string with no consecutive one's are : " << one << endl;
    }
    else
    {
        cout << "string with no consecutive one's are : " << two << endl;
    }
    return 0;
}